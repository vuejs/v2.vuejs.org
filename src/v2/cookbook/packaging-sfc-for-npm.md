---
title: Packaging Vue Components for npm
type: cookbook
order: 12
---

## Base Example

Vue components by nature are meant to be re-used. This is easy when the component is only used within a single application. But how can you write a component once and use it in multiple sites/applications? Perhaps the easiest solution is via npm.

By packaging your component to be shared via npm, it can be imported/required into a build process for use in full-fledged web applications:

```js
import MyComponent from 'my-component';

export default {
  components: {
    MyComponent,
  },
  // rest of the component
}
```

Or even used via `<script>` tag in the browser directly:

```html
  <!doctype html>
  <html>

  <head>
    <title>Testing My Component</title>
    <script src="https://unpkg.com/vue"></script>
    <script src="https://unpkg.com/my-component"></script>
  </head>

  <body>
    <p>Try out my component!</p>
    <div id="vue-target">
      <my-component></my-component>
    </div>

    <script>
    // For Vue 2: Vue.use(...)
    Vue.use(MyComponent);
    var app = new Vue({
      el: '#vue-target',
    });

    // For Vue 3: app.use(...)
    var app = Vue.createApp();
    app.use(MyComponent).mount('#vue-target');
    </script>
  </body>

  </html>
```

Not only does this help you avoid copy/pasting components around, but it also allows you to give back to the Vue community!

## Can't I Just Share `.vue` Files Directly?

Vue already allows components to be written as a single file. Because a Single File Component (SFC) is already just one file, you might ask:

> "Why can't people use my `.vue` file directly? Isn't that the simplest way to share components?"

It's true, you can share `.vue` files directly, and anyone using a [Vue build](https://vuejs.org/v2/guide/installation.html#Explanation-of-Different-Builds) containing the Vue compiler can consume it immediately. Also, the SSR build uses string concatenation as an optimization, so the `.vue` file might be preferred in this scenario (see [Packaging Components for npm > SSR Usage](#SSR-Usage) for details). However, this excludes anyone who wishes to use the component directly in a browser via `<script>` tag, anyone who uses a runtime-only build, or build processes which don't understand what to do with `.vue` files.

Properly packaging your SFC for distribution via npm enables your component to be shared in a way which is ready to use everywhere!

## Packaging Components for npm

For the purposes of this section, assume the following file structure:

```
package.json
build/
   rollup.config.js
src/
   wrapper.js
   my-component.vue
dist/
```

<p class="tip">Throughout this document, references are made to the package.json file listed above. The file used in these examples was generated by hand, and will include the minimum configuration required for the discussion/task at hand. It is likely your own package.json file will contain a lot more than is listed here.</p>

### A note about Vue 2 and Vue 3

Regarding Vue 3, there are a number of things which have changed in its tooling. What this means is that in order for Vue 2 components to work with Vue 3, they might not need much in terms of _rewriting_, but they will likely have to be _recompiled_. The examples here were originally written with Vue 2 in mind, but any changes required for Vue 3 will be indicated.

### How does npm know what to serve to a browser/build process?

The package.json file used by npm really only requires one javascript file (`main`), but as it turns out, we aren't limited to that. We can address the most common use cases by specifying 2 additional files (`module` and `unpkg`), and using the `browser` property. The `.vue` file can also be included in the package for those who need access to it. A sample package.json would look like this:

```json
{
  "name": "my-component",
  "version": "1.2.3",
  "main": "dist/my-component.ssr.js",
  "browser": "dist/my-component.esm.js",
  "module": "dist/my-component.esm.js",
  "unpkg": "dist/my-component.min.js",
  "files": [
    "dist/*",
    "src/**/*.vue"
  ],
  ...
}
```

When webpack 2+, Rollup, or other modern build tools are used, by default they will pick up the `module` build via the `browser` property or the `module` property itself (exactly which can vary, hence the duplication). Node.js and many legacy applications would use the `main` build, and the `unpkg` build can be used directly in browsers. In fact, the [unpkg](https://unpkg.com) cdn automatically uses this when someone enters the URL for your module into their service! By specifying the `files` property in package.json, we tell npm what files will be included in our package - in this case, the source `.vue` files are included as well as the transpiled ones for optional SSR usage.

### SSR Usage

When people use Vue components in "universal" or "isomorphic" apps, the SSR build of Vue is tuned differently than the browser build for performance reasons. By using the optimization features provided as part of our bundling process, we can produce a build which is compatible with the tuning that Vue SSR expects (see [Packaging Components for npm > How do I configure the the Rollup Build](#How-do-I-configure-the-Rollup-build) for implementation). It is likely that most of these apps will be running on Node.js, so this build should be the `main` build specified. If a developer still wants to utilize the `.vue` source files, they can still be included in the package, but those developers will need to reference them by file path instead of just package name. For example:

```js
// Node.js app - using 'require' instead of 'import'
var MyComponent = require('my-component'); // Returns package.json 'main', the ssr build
var MyComponentSrc = require('my-component/src/my-component.vue'); // Returns source '.vue' file
```

With either option, the SSR process can use the string concatenation optimizations it needs to for a boost in performance.

<p class="tip">Note: When producing SSR compatible components, pay attention to any type of pre-processing required by `script` and `style` tags. These dependencies will be passed on to developers using `.vue` components directly. Consider providing 'plain' SFCs to keep things as light as possible.</p>

### How do I make multiple builds of my component?

There is no need to write your module multiple times. It is possible to prepare all 3 builds of your module in one step, in a matter of seconds. The example here uses [Rollup](https://rollupjs.org) due to its minimal configuration, but similar configuration is possible with other build tools - more details on this decision can be found [here](https://medium.com/webpack/webpack-and-rollup-the-same-but-different-a41ad427058c). The package.json `scripts` section can be updated with a single entry for each build target, and a more generic `build` script that runs them all in one pass. The sample package.json file now looks like this:

```json
{
  "name": "my-component",
  "version": "1.2.3",
  "main": "dist/my-component.ssr.js",
  "browser": "dist/my-component.esm.js",
  "module": "dist/my-component.esm.js",
  "unpkg": "dist/my-component.min.js",
  "files": [
    "dist/*",
    "src/**/*.vue"
  ],
  "scripts": {
    "build": "npm run build:umd & npm run build:es & npm run build:unpkg",
    "build:ssr": "rollup --config build/rollup.config.js --format cjs --file dist/my-component.ssr.js",
    "build:es": "rollup --config build/rollup.config.js --format es --file dist/my-component.esm.js",
    "build:unpkg": "rollup --config build/rollup.config.js --format iife --file dist/my-component.min.js"
  },
  "devDependencies": {
    "@babel/core": "^7.11.4",
    "minimist": "^1.2.0",
    "rollup": "^2.26.5",
    "@rollup/plugin-babel": "^5.2.0",
    "@rollup/plugin-commonjs": "^14.0.0",
    "rollup-plugin-vue": "^5.1.9",
    "vue": "^2.6.12",
    "vue-template-compiler": "^2.6.12"
    ...
  },
  ...
}

// NOTE: Ensure that the package versions listed in your package.json file
// support the desired version of Vue. For example, Vue 2 is targeted by
// "rollup-plugin-vue" v5, while v6 supports Vue 3.

// To compile for Vue 3, the "vue" version must be >= 3, the version of
// "rollup-plugin-vue" must be >= 6, and the "vue-template-compiler" package
// is replaced with "@vue/compiler-sfc" >= 3. Finally, to process
// CSS, "rollup-plugin-postcss" must be used.
```

<p class="tip">Remember, if you have an existing package.json file, it will likely contain a lot more than this one does. This merely illustrates a starting point. Also, the <i>packages</i> listed in devDependencies (not their versions) are the minimum requirements for rollup to create the three separate builds (ssr, es, and unpkg) mentioned. As newer versions become available, they should be updated as necessary.</p>

Our changes to package.json are complete. Next, we need a small wrapper to export the actual SFC, plus a minimal Rollup configuration, and we're set!

### What does my packaged component look like?

Depending on how your component is being used, it needs to be exposed as either a [CommonJS](https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#c33a) javascript module, an [ES6 javascript](https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#4f5e) module, or in the case of a `<script>` tag, exposed as a global variable which can then be registered with Vue via `Vue.use(...)` in the case of Vue 2, or `app.use(...)` in Vue 3. This is accomplished by a simple wrapper.js file which handles the module export and auto-install. That wrapper, in its entirety, looks like this:

```js
// Import vue component
import component from './my-component.vue';

// Declare install function executed by .use()
const install = function installMyComponent(VueApp) {
	VueApp.component('MyComponent', component);
}

// Inject install function into component - allows component
// to be registered via .use() as well as .component()
component.install = install;

// To allow use as module (npm/webpack/etc.) export component
export default component;
```

Notice the first line directly imports your SFC, and the last line exports it again with an `install` function attached. As indicated by the comments in the rest of the code, the wrapper simply defines that `install` function for Vue.

You may have seen elsewhere on the web that some components attempt to automatically detect Vue and install the component - in fact, this recipe used to include code to do just that. This is now considered an anti-pattern, as Vue 3 does not allow components to be registered with the global instance.

Now that this wrapper is complete, 90% of the work is done. It's time to sprint to the finish!

### How do I configure the Rollup build?

With the package.json `scripts` section ready and the SFC wrapper in place, all that is left is to ensure Rollup is properly configured. Fortunately, this can be done with a small rollup.config.js file. Below are two examples, for Vue 2 as well as Vue 3:

```js
// For Vue 2
import commonjs from '@rollup/plugin-commonjs'; // Convert CommonJS modules to ES6
import vue from 'rollup-plugin-vue'; // Handle .vue SFC files
import babel from '@rollup/plugin-babel'; // Transpile/polyfill modern JS features
import minimist from 'minimist'; // Parse build command

const argv = minimist(process.argv.slice(2)); // Access build args as an object

export default {
    input: 'src/wrapper.js', // Path relative to package.json
    output: {
        name: 'MyComponent',
        exports: (argv.format === 'es') ? 'named' : 'auto',
    },
    plugins: [
        vue({
            css: true, // Dynamically inject css as a <style> tag
            template: {
                isProduction: true,
                // Only optimize for SSR in that build - see
                // https://vue-loader.vuejs.org/options.html#optimizessr
                optimizeSSR: (argv.format === 'cjs')
            },
        }),
        babel({
            exclude: 'node_modules/**',
            extensions: ['.js', '.jsx', '.ts', '.tsx', '.vue'],
            babelHelpers: 'bundled',
        }), // Transpile to ES5
        commonjs(),
    ],
};
```

```js
// For Vue 3
import commonjs from '@rollup/plugin-commonjs'; // Convert CommonJS modules to ES6
import vue from 'rollup-plugin-vue'; // Handle .vue SFC files
import babel from '@rollup/plugin-babel'; // Transpile/polyfill modern JS features
import PostCSS from 'rollup-plugin-postcss'; // Handle CSS
import minimist from 'minimist'; // Parse build command

const argv = minimist(process.argv.slice(2)); // Access build args as an object

export default {
    input: 'src/wrapper.js', // Path relative to package.json
    output: {
        name: 'MyComponent',
        exports: (argv.format === 'es') ? 'named' : 'auto',
    },
    plugins: [
        vue(),
        // Process only `<style module>` blocks.
        PostCSS({
            modules: {
                generateScopedName: '[local]___[hash:base64:5]',
            },
            include: /&module=.*\.css$/,
        }),
        // Process all `<style>` blocks except `<style module>`.
        PostCSS({ include: /(?<!&module=.*)\.css$/ }),
        babel({
            exclude: 'node_modules/**',
            extensions: ['.js', '.jsx', '.ts', '.tsx', '.vue'],
            babelHelpers: 'bundled',
        }), // Transpile to ES5
        commonjs(),
    ],
};
```

The sample config files contain the minimum settings to package your SFC for npm. There is room for customization, such as extracting CSS to a separate file, using a CSS preprocessor, uglifying the JS output, etc.

Also, it is worth noting the `name` given the component here. This is a PascalCase name that the component will be given, and should correspond with the kebab-case name used elsewhere throughout this recipe. It is also the name of the global variable created by `<script>` tags for registering the component with `Vue.use(...)` or `app.use(...)`.

### Will this replace my current development process?

The configuration here is not meant to replace the development process that you currently use. If you currently have a webpack setup with hot module reloading (HMR), keep using it! If you're starting from scratch, feel free to install [Vue CLI 3](https://github.com/vuejs/vue-cli/), or even [Vite](https://github.com/vitejs/vite) (Vue 3 only), which both give you the whole HMR experience config free:

```bash
# Vue cli:
vue serve --open src/my-component.vue

# Vite (with corresponding index.html):
vite serve --open ./
```

In other words, do all of your development in whatever way you are comfortable. The things outlined in this recipe are more like 'finishing touches' than a full dev process.

## When to Avoid this Pattern

Packaging SFCs in this manner might not be a good idea in certain scenarios. This recipe doesn't go into detail on how the components themselves are written. Some components might provide side effects like directives, or extend other libraries with additional functionality. In those cases, you will need to evaluate whether or not the changes required to this recipe are too extensive.

In addition, pay attention to any dependencies that your SFC might have. For example, if you require a third party library for sorting or communication with an API, Rollup might roll those packages into the final code if not properly configured. To continue using this recipe, you would need to configure Rollup to exclude those files from the output, then update your documentation to inform your users about these dependencies.

## Alternative Patterns

Vue CLI 3 comes with a built-in `library` build mode, which creates CommonJS and UMD builds of a component. This might be adequate for your use cases, though you will still need to make sure your package.json file points to `main` and `unpkg` properly. Also, Vue CLI is based on webpack, so there is no ES6 `module` output due to current webpack limitations.

## Acknowledgements

This recipe is the result of a lightning talk given by [Mike Dodge](https://twitter.com/webdevdodge) at VueConf.us in March 2018. He has published a utility to npm which will quickly scaffold a sample SFC using this recipe. You can download the utility, [vue-sfc-rollup](https://www.npmjs.com/package/vue-sfc-rollup), from npm. You can also [clone the repo](https://github.com/team-innovation/vue-sfc-rollup) and customize it.
